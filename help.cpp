#include <iostream>

using namespace std;

// C++ компилируемый язык программирования со статической типизацией
// Существуют типы данных:
// Тип без значения: void = () 
// Логический:      bool = true | false     ; 1 байт
// Символы:         char =   -128 .. 127    ; 1 байт
// Целочисленный:  short = –32768 .. 32767  ; 2 байтa
//                 int   = ну тут понятно   ; 2 | 4 байтa
//                 long  = ну тут понятно   ; 4 байтa
//            long long  = ну тут понятно   ; 8 байтa
// Вещественный:  float  = лень писать      ; 4 байтa
//               double  = лень писать      ; 8 байтa
//
// Есть также добавочки как signed unsigned, соответственно
// число со знаком или без, т.е:
// unsigned char = 0 .. 255
// signed   char = -128 .. 127

// объявление переменных:

// bool       a;
// char       b;
// short      c;
// int        d; 
// long       e;
// long long  f;
// float      g;
// double     h;

// и в них будет мусор

// чтобы не было мусора присваивайте значение: 

bool       a = true;
char       b = 'b';
short      c = 0;
int        d = 0; 
long       e = 0;
long long  f = 0;
float      g = 0.0; // 0, 0. , .0
double     h = 0.0;

// указатели
// ну они указывают ( логично ), на то что Влад не знает С++ ( логично ^2 ) 

void pointers(){
    int x = 10;
    int *p; // это указатель, объявляется с помощью *
    p = &x; // & берет адрес, по которому хранится переменная x
    // теперь p == x
    cout << "До: " << endl;
    cout << "x = " << x << endl;   // x = 10
    cout << "p = " << p << endl;   // p = 0x7ffe808bc16c (адрес) 
    cout << "*p = " << *p << endl; // *p = 10
    // операция * называется операцией разыменования ( получаем доступ к ячейке по адресу
    *p = 11; // изменяем в ячейке число с 10 на 11
    cout << "После: " << endl;
    cout << "x = " << x << endl;   // x = 11 ( тоже изменилось ) 
    cout << "p = " << p << endl;   // p = 0x7ffe808bc16c
    cout << "*p = " << *p << endl; // *p = 11
}


// массивы 
void arrays(){

    int array1[10]; // объявили пустой массив из 10 элементов заполненый мусором
    int array2[10] = {0}; // объявили массив и заполнили все ячейки 0
    int array3[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // объявили массив и заполнили все ячейки
    cout << array3[0] << endl; // выведет 0 
    cout << *array3 << endl;   // выведет 0 т.к. массивы это фактически указатели

    cout << array3[1] << endl;     // выведет 1
    cout << *(array3 + 1) << endl; // выведет 1, потому что мы к указателю прибавили 1 ( т.е. адрес сдвинулся на 2 или 4 байта ), 
    //разыменовали и получили следующий элемент

    cout << array3[1] + array3[2]<< endl; // выведет 3
    cout << *(array3 + 1) + 10 << endl; // выведет 11 т.к. приоритет у * больше


    // там еще есть всякие мудреные штуки, но я не помню их, и я думаю вам не надо
}
// Ветления, условия
// if ( что-то ) { делаем это } else { вот это} 

void conditions(){

    int a = 10;
    int b = 10; 

    if( a == b ){ // == оператор сравнения
        // заходим, когда условие = true
        cout << "lol" << endl;
    }
    else {
        // заходим, когда условие = false 
        cout << "kek" << endl;
    }

    // если используется после if или else всего одна строчка, то можно писать без фигурных скобок:

    if( a == b )
        cout << "lol" << endl;
    else
        cout << "kek" << endl;


    // можно делать также цепочку из из условия, если использовать
    if( a < b ){ 
        // не заходим
        cout << "lol" << endl;
    }
    else if ( a > b ) {
        // не заходим 
        cout << "kek" << endl;
    }
    else {
        // наша остановочка!
        cout << "lol kek" << endl;
    }


    // чтобы не делать много таких условий придумали такую функцию как switch
    // switch ( переменная ) {
    //     case 1:
    //          делаем что-то;
    //          break; // и выходим, иначе пройдет по всем кейсам ниже
    //     case 2:
    //          делаем что-то;
    //          break; // и выходим, иначе пройдет по всем кейсам ниже
    //     case 3:
    //          делаем что-то;
    //          break; // и выходим, иначе пройдет по всем кейсам ниже
    //     default : 
    //          если не совпало ни с чем, то делаем это;
    //          break;
    // }

    switch (a) {
        case 0:
            cout << "0" << endl;
            break;
        case 5:
            cout << "5" << endl;
            break;
        case 10:
            cout << "10" << endl;
            break;
        default:
            cout << "Ой, нет совпадений((" << endl;
            break;
    }
    // конечно же напечатается 10
}

// Циклы!!

void cycles(){
    // Цикл с предусловием
    int i = 0;
    while( i != 10 ){ // пока условие выполняется заходим внутрь, если условие не выполняется, то не зайдем ни один раз
        cout << i << endl;
        i++; // прибавляем счетчик
    }
    // в итоге напечатаем все числа от 0 до 9
    //
    // Цикл с постусловием
    i = 0;
    do { // заходим 1 раз в любом случае
        cout << i << endl;
        i++;
    } while (i == 0); // выходим, когда условие не выполяется
    // в итоге зайдем только 1 раз, напечатаем 0,
    // а потом выйдем, потому что i не будет равно 0, а будет равно 1  

    // цикл с итератором ( не нуждается в посторонних переменных) 
    //for(;;){} тоже самое, что и while(true), т.е. бесконечный цикл

    for(int i = 0; i < 10; i++)
        cout << i << endl;
    // опять напечатаем числа от 0 до 9
}

// чет я уже устал(( 

// Функции :
// <тип возвращаемого значения> название( <тип аргумента1> имя_аргумента_1, ..){return ..; }


// функция ничего не делает, и ничего не возвращает
void kek(){}

// функция возвращает 1
int lol(){ 
    return 1;
    int a = 2 + 3; // никогда сюда не дойдем
}

// функция принимающая 2 аргумента и возвращающая сумму этих элементов
int plusFunc( int a, int b ) {
    return a + b;
}

// можно также принимать указатели как аргументы, допустим чтобы передать массив, или возвращать указатели, можно даже принимать и возвращать указатели на функции, но кто я такое, и кто вы такие, чтобы все это знать)) 

//return - выход из функции сразу же, все что после return не выполняется

// полиморфизм, это когда у нас две одинаковые фунции могут работать с разными типами входных данных, например сейчас сделаем полиморфную функцию plusFunc, которая может принимать 2 вещественных числа:


double plusFunc( double a, double b ) {
    return a + b;
}

void testFunc(){
    cout << plusFunc(1.5, 2.0) << endl; // выведет 3.5
    cout << plusFunc(1, 2)     << endl; // выведет 3
    // вот он и полиморфизм
}

// наследование и инкапсуляцию прочитай в 31 задаче, я сейчас там все распишу

// основная функция ( точка входа в программу )
int main(){

    cout << 1 / 10   << endl; // выведет 0, т.к. 1 это int, и деление будет как div
    cout << 1.0 / 10 << endl; // будет 0.1, т.к. 1.0 тут уже double
    cout << 1. / 10  << endl; // будет 0.1, т.к. 1.  тут уже double
    cout << .1 / 10  << endl; // будет 0.01, т.к. .1 ( это 0.1) тоже double 

    pointers();
    arrays();
    conditions();
    cycles();
    testFunc();
    return 0;
}
